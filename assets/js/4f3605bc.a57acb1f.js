"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4022],{6613:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(9593);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},7225:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"home/components/sync-service","title":"Sync Protocols & Chain Config","description":"The Sync Service is the core data-ingestion layer of a Paima Engine node. It acts as the engine\'s monitor connecting to different blockchains, checking for specific on-chain events, and feeding them in a deterministic, ordered stream to the State Machine.","source":"@site/docs/home/100-components/101-sync-service.md","sourceDirName":"home/100-components","slug":"/home/components/sync-service","permalink":"/home/components/sync-service","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/101-sync-service.md","tags":[],"version":"current","sidebarPosition":101,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Paima Engine Components","permalink":"/home/components/"},"next":{"title":"State Machine","permalink":"/home/components/state-machine"}}');var o=t(3261),s=t(6613);const r={},l="Sync Protocols & Chain Config",a={},c=[{value:"The <code>ConfigBuilder</code>",id:"the-configbuilder",level:2},{value:"Step 1: Defining Networks (<code>buildNetworks</code>)",id:"step-1-defining-networks-buildnetworks",level:3},{value:"Step 2: Defining Deployments (<code>buildDeployments</code>)",id:"step-2-defining-deployments-builddeployments",level:3},{value:"Step 3: Defining Sync Protocols (<code>buildSyncProtocols</code>)",id:"step-3-defining-sync-protocols-buildsyncprotocols",level:3},{value:"Available Sync Protocols",id:"available-sync-protocols",level:3},{value:"The Main Protocol: A Deterministic Clock",id:"the-main-protocol-a-deterministic-clock",level:4},{value:"Parallel Protocols: Real-World Data Sources",id:"parallel-protocols-real-world-data-sources",level:4},{value:"Configuration Example",id:"configuration-example",level:3},{value:"Step 4: Defining Primitives (<code>buildPrimitives</code>)",id:"step-4-defining-primitives-buildprimitives",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"sync-protocols--chain-config",children:"Sync Protocols & Chain Config"})}),"\n",(0,o.jsxs)(n.p,{children:["The Sync Service is the core data-ingestion layer of a ",(0,o.jsx)(n.code,{children:"Paima Engine"})," node. It acts as the engine's monitor connecting to different blockchains, checking for specific on-chain events, and feeding them in a deterministic, ordered stream to the ",(0,o.jsx)(n.a,{href:"/home/components/state-machine",children:"State Machine"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["This entire service is configured using the ",(0,o.jsx)(n.code,{children:"ConfigBuilder"}),", a powerful tool that allows you to define exactly which chains to connect to and what data to capture."]}),"\n",(0,o.jsxs)(n.h2,{id:"the-configbuilder",children:["The ",(0,o.jsx)(n.code,{children:"ConfigBuilder"})]}),"\n",(0,o.jsxs)(n.p,{children:["The configuration is built using a fluent, step-by-step interface called the ",(0,o.jsx)(n.code,{children:"ConfigBuilder"}),". This pattern guides you through the process of defining the components of your data pipeline, ensuring a valid and coherent setup."]}),"\n",(0,o.jsx)(n.p,{children:"The main steps are:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Define Networks"}),": Specify which blockchains you want to connect to."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Define Deployments (Optional)"}),": Create aliases for your deployed contract addresses for cleaner configuration."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Define Sync Protocols"}),": Specify ",(0,o.jsx)(n.em,{children:"how"})," the engine should sync data from each network."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Define Primitives"}),": Specify ",(0,o.jsx)(n.em,{children:"what specific events"})," the engine should listen for on those networks."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Let's break down each step using a real-world multi-chain example."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// The entry point is always creating a new ConfigBuilder instance\nexport const localhostConfig = new ConfigBuilder()\n    // ... chain the build steps\n    .build();\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"step-1-defining-networks-buildnetworks",children:["Step 1: Defining Networks (",(0,o.jsx)(n.code,{children:"buildNetworks"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"This is where you list all the blockchains your application will interact with. Each network is given a unique name for reference in later steps. Paima Engine supports various network types."}),"\n",(0,o.jsxs)(n.p,{children:["In this example, we define an EVM network (",(0,o.jsx)(n.code,{children:"evmParallel_fast"}),"), a private Midnight network, and a special ",(0,o.jsx)(n.code,{children:"NTP"})," network that acts as a deterministic clock."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'.buildNetworks(builder =>\n    builder\n      // A special network that isn\'t a blockchain, but a deterministic clock.\n      // It produces a new "block" every `blockTimeMS`.\n      .addNetwork({\n        name: "ntp",\n        type: ConfigNetworkType.NTP,\n        startTime: new Date().getTime(),\n        blockTimeMS: 1000, // A new block every 1 second\n      })\n      // An EVM network using viem\'s chain definitions\n      .addViemNetwork({\n        ...hardhat, // Base configuration from viem\n        name: "evmParallel_fast",\n      })\n      // A Zero-Knowledge network\n      .addNetwork({\n        name: "midnight",\n        type: ConfigNetworkType.MIDNIGHT,\n        // ... midnight specific configuration\n      })\n  )\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"step-2-defining-deployments-builddeployments",children:["Step 2: Defining Deployments (",(0,o.jsx)(n.code,{children:"buildDeployments"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"This optional but highly recommended step allows you to register the addresses of your deployed smart contracts. This keeps your configuration clean, as you can refer to contracts by name instead of repeatedly pasting addresses."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'.buildDeployments((builder) =>\n    builder\n      .addDeployment(\n        (networks) => networks.evmParallel_fast, // Target the network\n        (_network) => ({\n          name: "PaimaErc20DevModule#PaimaErc20Dev", // A unique name for this contract\n          address: "0x...", // The contract\'s address. Generated and available in the @example/contract-evm package\n        }),\n      )\n  )\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"step-3-defining-sync-protocols-buildsyncprotocols",children:["Step 3: Defining Sync Protocols (",(0,o.jsx)(n.code,{children:"buildSyncProtocols"}),")"]}),"\n",(0,o.jsxs)(n.p,{children:["This is the most critical step. Here, you define ",(0,o.jsx)(n.em,{children:"how"})," Paima Engine will fetch data from the networks you defined. There are two types of protocols: ",(0,o.jsx)(n.strong,{children:"Main"})," and ",(0,o.jsx)(n.strong,{children:"Parallel"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"available-sync-protocols",children:"Available Sync Protocols"}),"\n",(0,o.jsxs)(n.p,{children:["When you define a sync protocol using ",(0,o.jsx)(n.code,{children:".addMain()"})," or ",(0,o.jsx)(n.code,{children:".addParallel()"}),", you must specify its ",(0,o.jsx)(n.code,{children:"type"}),". This tells the Paima Engine what kind of data source it's connecting to and how to interpret the data."]}),"\n",(0,o.jsx)(n.h4,{id:"the-main-protocol-a-deterministic-clock",children:"The Main Protocol: A Deterministic Clock"}),"\n",(0,o.jsxs)(n.p,{children:['In Paima Engine, your application\'s "heartbeat" is driven by a single ',(0,o.jsx)(n.strong,{children:"Main"})," protocol. This protocol's block progression defines the official timeline for your entire state machine. All events from all other connected chains are deterministically mapped onto this timeline."]}),"\n",(0,o.jsx)(n.p,{children:"For maximum consistency and to decouple your application's tick-rate from the variable block times of real-world blockchains, the main protocol is always a Network Time Protocol (NTP) clock."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ConfigSyncProtocolType.NTP_MAIN"})}),': This protocol is not a blockchain. It is a high-precision, deterministic clock that produces a new "block" at a fixed interval (e.g., every 1000 milliseconds). This creates a perfectly stable tick-rate for your game or dApp, ensuring that time-based logic is predictable and consistent across all nodes.']}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'.addMain(\n    (networks) => networks.ntp, // Target the NTP network\n    (network, deployments) => ({\n        name: "mainNtp",\n        type: ConfigSyncProtocolType.NTP_MAIN, // The only valid type for `addMain`\n        // ...\n    })\n)\n'})}),"\n",(0,o.jsx)(n.h4,{id:"parallel-protocols-real-world-data-sources",children:"Parallel Protocols: Real-World Data Sources"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Parallel"})," protocols run alongside the main clock and are responsible for fetching data from actual blockchains. You can add as many parallel protocols as you need to create a rich, multi-chain application."]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{style:{textAlign:"left"},children:"Protocol Type"}),(0,o.jsx)(n.th,{style:{textAlign:"left"},children:"Target Blockchain"}),(0,o.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{style:{textAlign:"left"},children:(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"EVM_RPC_PARALLEL"})})}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"EVM"}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"The most common type. Connects to any EVM-compatible chain (like Ethereum, Arbitrum, Polygon) via a standard JSON-RPC endpoint to fetch block data and logs."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{style:{textAlign:"left"},children:(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"CARDANO_CARP_PARALLEL"})})}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Cardano"}),(0,o.jsxs)(n.td,{style:{textAlign:"left"},children:["Connects to the Cardano network using a ",(0,o.jsx)(n.a,{href:"https://dcspark.github.io/carp/docs/intro",children:"Carp"})," indexer."]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{style:{textAlign:"left"},children:(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"CARDANO_UTXORPC_PARALLEL"})})}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Cardano"}),(0,o.jsxs)(n.td,{style:{textAlign:"left"},children:["An alternative way to connect to Cardano using a ",(0,o.jsx)(n.a,{href:"https://www.utxorpc.org/",children:"UTXO-RPC"})," compatible service like Dolos."]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{style:{textAlign:"left"},children:(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"MINA_PARALLEL"})})}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Mina"}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Connects to the Mina Protocol to sync data from zkApps."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{style:{textAlign:"left"},children:(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"AVAIL_PARALLEL"})})}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Avail"}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Connects to the Avail Data Availability (DA) layer to fetch application-specific data blobs."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{style:{textAlign:"left"},children:(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"MIDNIGHT_PARALLEL"})})}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Midnight"}),(0,o.jsx)(n.td,{style:{textAlign:"left"},children:"Connects to the Midnight network to sync state from its ZK-powered smart contracts."})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,o.jsxs)(n.p,{children:["Here is how you would combine these protocols in a ",(0,o.jsx)(n.code,{children:"ConfigBuilder"})," to create a multi-chain application that has a 1-second tick rate and pulls in data from an EVM chain and a Midnight network simultaneously."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'.buildSyncProtocols((builder) =>\n    builder\n      // 1. Define the main clock for the entire application.\n      .addMain(\n        (networks) => networks.ntp,\n        (network, deployments) => ({\n          name: "mainNtp",\n          type: ConfigSyncProtocolType.NTP_MAIN,\n          startBlockHeight: 1,\n          pollingInterval: 1000,\n        }),\n      )\n      // 2. Add a parallel protocol to sync data from an EVM chain.\n      .addParallel(\n        (networks) => networks.evmParallel_fast,\n        (network, deployments) => ({\n          name: "parallelEvmRPC_fast",\n          type: ConfigSyncProtocolType.EVM_RPC_PARALLEL,\n          chainUri: network.rpcUrls.default.http[0],\n          startBlockHeight: 1,\n          pollingInterval: 500,\n        }),\n      )\n      // 3. Add another parallel protocol to sync data from Midnight.\n      .addParallel(\n        (networks) => networks.midnight,\n        (network, deployments) => ({\n          name: "parallelMidnight",\n          type: ConfigSyncProtocolType.MIDNIGHT_PARALLEL,\n          startBlockHeight: 1,\n          pollingInterval: 1000,\n          indexer: "http://127.0.0.1:8088/api/v1/graphql",\n        }),\n      )\n  )\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"step-4-defining-primitives-buildprimitives",children:["Step 4: Defining Primitives (",(0,o.jsx)(n.code,{children:"buildPrimitives"}),")"]}),"\n",(0,o.jsx)(n.p,{children:'Primitives are the specific event listeners. This is where you tell the engine, "On this protocol, watch this contract for this specific event."'}),"\n",(0,o.jsxs)(n.p,{children:["Each primitive is linked to a ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"scheduledPrefix"})}),". This prefix is the crucial link between the Sync Service and the State Machine. When a primitive detects an event, it creates an input with this prefix, which in turn triggers the corresponding State Transition Function (STF)."]}),"\n",(0,o.jsxs)(n.p,{children:["In this example, we are tracking the ",(0,o.jsx)(n.code,{children:"Transfer"})," event from an ERC20 contract."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'.buildPrimitives(builder =>\n    builder.addPrimitive(\n        // 1. Select the protocol to listen on.\n        (syncProtocols) => syncProtocols.parallelEvmRPC_fast,\n\n        // 2. Define the primitive\'s properties.\n        (network, deployments, syncProtocol) => ({\n          name: "My_ERC20_Token",\n          type: ConfigPrimitiveType.EvmRpcERC20, // This primitive automatically tracks ERC20 balances.\n          startBlockHeight: 0,\n          contractAddress: deployments["PaimaErc20DevModule#PaimaErc20Dev"].address,\n          abi: getEvmEvent(erc20dev.abi, "Transfer(address,address,uint256)"),\n\n          // 3. The link to the State Machine.\n          // This will trigger the STF registered with the name "transfer".\n          scheduledPrefix: "transfer",\n        })\n    )\n  )\n'})}),"\n",(0,o.jsx)(n.p,{children:"By combining these steps, you create a powerful, multi-chain data pipeline that transforms raw on-chain events into a clean, ordered set of inputs for your application logic."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);