"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8290],{2117:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"home/components/frontend","title":"Frontend (dApp)","description":"The frontend is the user-facing part of your decentralized application, such as a web-based game or a user dashboard. Its primary role is to provide an interface for users to interact with your dApp\'s state.","source":"@site/docs/home/100-components/115-frontend.md","sourceDirName":"home/100-components","slug":"/home/components/frontend","permalink":"/paima-v-next-docs/ja/home/components/frontend","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/115-frontend.md","tags":[],"version":"current","sidebarPosition":115,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Achievements","permalink":"/paima-v-next-docs/ja/home/components/achievements"},"next":{"title":"Accounts","permalink":"/paima-v-next-docs/ja/home/components/accounts"}}');var i=t(3261),s=t(6613);const r={},o="Frontend (dApp)",c={},d=[{value:"Getting Started",id:"getting-started",level:2},{value:"Universal JavaScript Compatibility",id:"universal-javascript-compatibility",level:2},{value:"Standard Web Frameworks",id:"standard-web-frameworks",level:4},{value:"Game Engines",id:"game-engines",level:4},{value:"Writing Data to the Blockchain (Writes)",id:"writing-data-to-the-blockchain-writes",level:2},{value:"Connecting a Wallet",id:"connecting-a-wallet",level:3},{value:"Submission Methods",id:"submission-methods",level:3},{value:"Reading Data from the Paima Engine (Reads)",id:"reading-data-from-the-paima-engine-reads",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frontend-dapp",children:"Frontend (dApp)"})}),"\n",(0,i.jsx)(n.p,{children:"The frontend is the user-facing part of your decentralized application, such as a web-based game or a user dashboard. Its primary role is to provide an interface for users to interact with your dApp's state."}),"\n",(0,i.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"/templates/evm-midnight/"})," template includes a ",(0,i.jsx)(n.code,{children:"/packages/frontend/"})," folder containing a complete, working web application to serve as a starting point."]}),"\n",(0,i.jsx)(n.p,{children:"A frontend's interaction with Paima Engine can be broken down into two main activities:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Writes"}),": Submitting new actions (transactions or signed messages) to the blockchain to change the application's state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reads"}),": Querying the Paima Engine's API to fetch and display the current, aggregated state of the application."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"universal-javascript-compatibility",children:"Universal JavaScript Compatibility"}),"\n",(0,i.jsxs)(n.p,{children:["A core design principle of Paima Engine's frontend libraries is that they are ",(0,i.jsx)(n.strong,{children:"framework-agnostic"}),". They are written in standard TypeScript and compile to JavaScript, meaning they are not tied to any specific UI framework like React or Vue."]}),"\n",(0,i.jsx)(n.p,{children:"This universality allows you to build your dApp with a wide range of tools."}),"\n",(0,i.jsx)(n.h4,{id:"standard-web-frameworks",children:"Standard Web Frameworks"}),"\n",(0,i.jsx)(n.p,{children:"You can seamlessly integrate Paima's frontend packages into any modern web framework:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"React & Next.js"}),"\n",(0,i.jsx)(n.li,{children:"Vue & Nuxt.js"}),"\n",(0,i.jsx)(n.li,{children:"Svelte & SvelteKit"}),"\n",(0,i.jsx)(n.li,{children:"And more..."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"game-engines",children:"Game Engines"}),"\n",(0,i.jsx)(n.p,{children:"This JavaScript-first approach is especially powerful for game developers. You can build your application using dedicated game engines and still connect to the Paima Engine backend. If your engine can compile to a web target (WebGL/HTML5) and interface with browser JavaScript, it can be a Paima-powered game."}),"\n",(0,i.jsx)(n.p,{children:"Integration is possible with many popular game engines:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unity"}),": Use ",(0,i.jsx)(n.code,{children:"*.jslib"})," files to bridge C# game logic with Paima's JavaScript libraries."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GameMaker"}),": Use the native extension system to call JavaScript functions from GML."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Godot"}),": Use the ",(0,i.jsx)(n.code,{children:"JavaScriptBridge"})," singleton for seamless communication between GDScript and JavaScript."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phaser.js & PixiJS"}),": As native JavaScript frameworks, integration is direct and straightforward."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"writing-data-to-the-blockchain-writes",children:"Writing Data to the Blockchain (Writes)"}),"\n",(0,i.jsx)(n.p,{children:"To change the state of the application, the frontend must initiate a transaction or a signed message."}),"\n",(0,i.jsx)(n.h3,{id:"connecting-a-wallet",children:"Connecting a Wallet"}),"\n",(0,i.jsxs)(n.p,{children:["All write operations begin with connecting a user's wallet. The ",(0,i.jsx)(n.code,{children:"@paima/wallet"})," package provides a unified interface for connecting to various blockchain ecosystems."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { WalletMode, login } from '@paima/wallet';\n\n// Example for an injected EVM wallet like MetaMask\nconst loginInfo = await login(WalletMode.EvmInjected);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Supported wallet modes include ",(0,i.jsx)(n.code,{children:"EvmInjected"}),", ",(0,i.jsx)(n.code,{children:"Cardano"}),", ",(0,i.jsx)(n.code,{children:"Mina"}),", ",(0,i.jsx)(n.code,{children:"AvailJs"}),", and more, enabling truly cross-chain applications."]}),"\n",(0,i.jsx)(n.h3,{id:"submission-methods",children:"Submission Methods"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direct Contract Interaction"}),": The standard Web3 approach where your frontend calls a function on a smart contract directly (e.g., minting an NFT)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direct Paima L2 Contract Interaction"}),": A specific direct interaction where your frontend calls the ",(0,i.jsx)(n.code,{children:"submitInput"})," method on your game's ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"})," with a grammar-formatted payload. The user pays the gas for this transaction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batcher Interaction"}),": The recommended approach for the best UX. The user signs a message, and the frontend sends it to a ",(0,i.jsx)(n.strong,{children:"Batcher"})," service via an HTTP request. The Batcher then submits the input on-chain, often covering the gas fee and allowing users from different chains to interact."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of a frontend submitting an input to the batcher:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { createMessageForBatcher } from \'@paima/concise\';\nimport { AddressType } from \'@paima/utils-backend\';\n\nconst appName = "";\nconst timestamp = Date.now();\nconst conciseInput = ["my-action", "0x1", "0x2"]; // Your grammar-formatted input\n\n\n// The user signs a message, not a transaction\nconst signature = await walletClient.signMessage({\n  message: createMessageForBatcher(\n    appName, timestamp, account.address, account.accountType, conciseInput\n  ),\n});\n\n// Send the signed payload to the Batcher via HTTP\nawait fetch(`${ENV.BATCHER_URL}/send-input`, {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify({ \n    data: {\n      userAddress: account.address,\n      addressType: account.accountType,\n      userSignature: signature,\n      conciseInput: conciseInput,\n      millisecondTimestamp: timestamp,\n    },\n    waitForConfirmation: "wait-paima-processed",\n  }),\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"reading-data-from-the-paima-engine-reads",children:"Reading Data from the Paima Engine (Reads)"}),"\n",(0,i.jsx)(n.p,{children:"While you can read data directly from the blockchain, it is often slow, inefficient, and doesn't provide the rich, aggregated state of your Paima application."}),"\n",(0,i.jsxs)(n.p,{children:["The recommended way for a frontend to read data is by querying the powerful ",(0,i.jsx)(n.strong,{children:"API"})," exposed by the Paima Engine Node. This API provides access to both built-in system data and your own custom application state."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/paima-v-next-docs/ja/home/components/api",children:"Learn more about the Paima Engine API"})})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},6613:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(9593);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);