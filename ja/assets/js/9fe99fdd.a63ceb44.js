"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5717],{4233:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"home/components/paima-l2-contract","title":"Paima L2 Contract","description":"The PaimaL2Contract is a specialized, gas-efficient smart contract that serves as the primary \\"mailbox\\" or data entry point for your Paima Engine application. While Paima can monitor any contract, the PaimaL2Contract is optimized for submitting user actions and game moves directly to your state machine.","source":"@site/docs/home/100-components/104-paima-l2-contract.md","sourceDirName":"home/100-components","slug":"/home/components/paima-l2-contract","permalink":"/ja/home/components/paima-l2-contract","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/104-paima-l2-contract.md","tags":[],"version":"current","sidebarPosition":104,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"API","permalink":"/ja/home/components/api"},"next":{"title":"Contracts","permalink":"/ja/home/components/contracts"}}');var i=t(3261),s=t(6613);const r={},c="Paima L2 Contract",o={},l=[{value:"Core Functionality",id:"core-functionality",level:3},{value:"How it Connects to the Grammar and State Machine",id:"how-it-connects-to-the-grammar-and-state-machine",level:3},{value:"Ownership and Monetization",id:"ownership-and-monetization",level:3},{value:"Built-in Grammar Commands (<code>&amp;</code>)",id:"built-in-grammar-commands-",level:3},{value:"Batched Inputs: <code>&amp;B</code>",id:"batched-inputs-b",level:4},{value:"Account Management Commands",id:"account-management-commands",level:4}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"paima-l2-contract",children:"Paima L2 Contract"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"}),' is a specialized, gas-efficient smart contract that serves as the primary "mailbox" or data entry point for your Paima Engine application. While Paima can monitor any contract, the ',(0,i.jsx)(n.code,{children:"PaimaL2Contract"})," is optimized for submitting user actions and game moves directly to your state machine."]}),"\n",(0,i.jsx)(n.p,{children:"Its design is intentionally simple: its main job is to accept arbitrary data from a user, wrap it in an event, and securely log that event on the blockchain for the Paima Engine to process."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/utils/Address.sol";\n\n/// @dev The main L2 contract for a Paima L2.\ncontract PaimaL2Contract {\n    // ... (events and state variables)\n\n    /// @dev Emits the `PaimaGameInteraction` event, logging the `msg.sender`, `data`, and `msg.value`.\n    /// Revert if `msg.value` is less than set `fee`.\n    function paimaSubmitGameInput(bytes calldata data) public payable {\n        require(msg.value >= fee, "Sufficient funds required to submit game input");\n        emit PaimaGameInteraction(msg.sender, data, msg.value);\n    }\n\n    // ... (owner-only administrative functions)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"core-functionality",children:"Core Functionality"}),"\n",(0,i.jsx)(n.p,{children:"The contract's logic centers around a single function and a single event."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"paimaSubmitGameInput(bytes calldata data)"})}),": This is the function your frontend will call. It accepts a single ",(0,i.jsx)(n.code,{children:"bytes"})," argument, which allows you to send any kind of data, but it's designed to carry a concise grammar formatted according to your application's ",(0,i.jsx)(n.a,{href:"/ja/home/components/grammar",children:"Grammar"})," (e.g., ",(0,i.jsx)(n.code,{children:'["attack","player1","monster7"]'}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"PaimaGameInteraction"})," Event"]}),": When ",(0,i.jsx)(n.code,{children:"paimaSubmitGameInput"})," is called, the contract does not perform any complex logic. It simply emits the ",(0,i.jsx)(n.code,{children:"PaimaGameInteraction"})," event, logging three crucial pieces of information onto the blockchain:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"userAddress"}),": The wallet address of the user who called the function (",(0,i.jsx)(n.code,{children:"msg.sender"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"data"}),": The raw ",(0,i.jsx)(n.code,{children:"bytes"})," payload that was submitted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"value"}),": The amount of cryptocurrency sent with the transaction (",(0,i.jsx)(n.code,{children:"msg.value"}),"), used for the optional fee."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"how-it-connects-to-the-grammar-and-state-machine",children:"How it Connects to the Grammar and State Machine"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"})," is the critical on-chain starting point that triggers your off-chain logic. The connection happens through a precise sequence of steps orchestrated by the Paima Engine:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Action"}),": A user on your frontend initiates an action, which calls ",(0,i.jsx)(n.code,{children:"paimaSubmitGameInput"})," on the deployed ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"})," with a formatted string (e.g., ",(0,i.jsx)(n.code,{children:'["attack","player1","monster7"]'}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event Emission"}),": The contract executes and emits the ",(0,i.jsx)(n.code,{children:"PaimaGameInteraction"})," event onto the blockchain."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sync Service Detection"}),": The Paima Engine's ",(0,i.jsx)(n.strong,{children:"Sync Service"}),", which is constantly monitoring the blockchain, has a ",(0,i.jsx)(n.strong,{children:"Primitive"})," configured to listen specifically for the ",(0,i.jsx)(n.code,{children:"PaimaGameInteraction"})," event from your contract's address."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Grammar Parsing"}),": When the Sync Service detects a new event, it takes the ",(0,i.jsx)(n.code,{children:"data"})," payload and passes it to the ",(0,i.jsx)(n.strong,{children:"Grammar Parser"}),". The parser checks the prefix (",(0,i.jsx)(n.code,{children:'["attack",...'}),") to identify which rule to apply. It then validates and parses the rest of the string into a structured, type-safe object."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"STF Execution"}),": The engine uses the parsed prefix to identify and execute the corresponding ",(0,i.jsx)(n.strong,{children:"State Transition Function (STF)"})," in your state machine (e.g., the function registered for ",(0,i.jsx)(n.code,{children:'"attack"'}),"). The parsed data object is passed as an argument to your STF, where your game logic runs."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This flow creates a secure and deterministic bridge from an on-chain event to your application's state."}),"\n",(0,i.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant User/Frontend\n    participant EVM Blockchain (PaimaL2Contract)\n    participant Paima Engine (Sync Service)\n    participant Paima Engine (Grammar Parser)\n    participant Paima Engine (State Machine)\n\n    User/Frontend->>EVM Blockchain (PaimaL2Contract): Calls `paimaSubmitGameInput("attack|p1|m7")`\n    EVM Blockchain (PaimaL2Contract)->>EVM Blockchain (PaimaL2Contract): Emits `PaimaGameInteraction` event\n    Paima Engine (Sync Service)->>EVM Blockchain (PaimaL2Contract): [Primitive] Detects Event\n    Paima Engine (Sync Service)->>Paima Engine (Grammar Parser): Passes raw data: ["attack","p1","m7"]\n    Paima Engine (Grammar Parser)->>Paima Engine (State Machine): Parses input and identifies \'attack\' prefix\n    Paima Engine (State Machine)->>Paima Engine (State Machine): Executes \'attack\' STF with parsed data'}),"\n",(0,i.jsx)(n.h3,{id:"ownership-and-monetization",children:"Ownership and Monetization"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"})," also includes administrative functions that allow the contract owner to manage it and optionally generate revenue."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"setOwner(address newOwner)"})}),": Transfers ownership of the contract to a new address."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"setFee(uint256 newFee)"})}),": Sets a fee (in wei) that users must pay to call ",(0,i.jsx)(n.code,{children:"paimaSubmitGameInput"}),". This is a simple way to monetize your dApp, as every action can contribute to a fee pool."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"withdrawFunds()"})}),": Allows the owner to withdraw the accumulated fees from the contract."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"built-in-grammar-commands-",children:["Built-in Grammar Commands (",(0,i.jsx)(n.code,{children:"&"}),")"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"These are low level internal commands.\nNormally you will not be directly using these mechanisms."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["While most of your application's grammar is custom-defined to handle your specific game logic, Paima Engine reserves a special prefix, ",(0,i.jsx)(n.code,{children:"&"}),", for a set of powerful, built-in system commands. These commands provide core functionalities common to most decentralized applications, including input batching and a flexible account management system."]}),"\n",(0,i.jsx)(n.p,{children:"These commands are processed directly by the Paima Engine before your custom State Transition Functions (STFs) are run."}),"\n",(0,i.jsxs)(n.h4,{id:"batched-inputs-b",children:["Batched Inputs: ",(0,i.jsx)(n.code,{children:"&B"})]}),"\n",(0,i.jsxs)(n.p,{children:["Submitting one on-chain transaction for every single user action can be slow and expensive, leading to a poor user experience. To solve this, Paima provides a batching mechanism, primarily used by the ",(0,i.jsx)(n.a,{href:"/ja/home/components/batcher",children:"Batcher service"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"&B"})," command allows multiple individual user inputs to be bundled together and submitted in a single on-chain transaction, significantly reducing costs and improving throughput."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Grammar:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'["&B","[input1,input2,input3,...]]\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"input"})}),": A JSON-formatted array of strings. Each string in the array is a complete, individual user input (e.g., ",(0,i.jsx)(n.code,{children:'"["attack","p1","m7"]'}),") that will be processed sequentially by the engine."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example Payload:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'[\n    "&B",\n        "[\\"signature\\", \\"wallet\\", \\"attack\\",\\"p1\\",\\"m7\\"]",\n        "[\\"signature\\", \\"wallet\\", \\"use_item\\",\\"p1\\",\\"potion\\"]",\n        "[\\"signature\\", \\"wallet\\", \\"move\\",\\"p1\\",\\"c3\\"]"\n]\n'})}),"\n",(0,i.jsx)(n.p,{children:"A key feature of this system is its robustness & security features. Each input within the batch is a string. If one of the inputs is malformed or invalid according to your grammar, the Paima Engine will simply skip that single input and continue processing the rest of the batch. This prevents a single bad actor or a frontend bug from causing an entire batch of valid transactions to fail."}),"\n",(0,i.jsxs)(n.p,{children:["Typically, you will not construct this ",(0,i.jsx)(n.code,{children:"&B"})," string manually. The Batcher service and the Paima frontend SDKs handle the creation and submission of batched inputs automatically."]}),"\n",(0,i.jsx)(n.h4,{id:"account-management-commands",children:"Account Management Commands"}),"\n",(0,i.jsx)(n.p,{children:'Paima Engine includes a flexible, L2-native account system that goes beyond simple wallet addresses. A single "Paima Account" can be controlled by multiple wallets (e.g., a hot wallet on a mobile device and a hardware wallet for security), and the primary controlling wallet can be changed. This provides a form of L2 Account Abstraction.'}),"\n",(0,i.jsxs)(n.p,{children:["These commands allow users to manage their Paima Account directly through the ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"&createAccount"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Creates a new, empty Paima Account. The wallet that sends this transaction (",(0,i.jsx)(n.code,{children:"msg.sender"}),") automatically becomes the first and primary address for this new account."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"&linkAddress"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Links a new wallet address to an existing Paima Account. This process is secured by requiring signatures from both the current primary wallet (proving control over the account) and the new wallet being linked (proving its ownership)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"&unlinkAddress"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Removes a wallet address from a Paima Account. This can be initiated either by the user themselves to leave an account, or by the primary wallet holder to remove another linked address."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["More in ",(0,i.jsx)(n.a,{href:"/ja/home/components/accounts",children:"accounts"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6613:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(9593);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);